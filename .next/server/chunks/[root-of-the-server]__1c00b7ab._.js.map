{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///D:/Saas_MongoDB/mongo/app/api/models.js"],"sourcesContent":["import mongoose from \"mongoose\";\n/**\n * Use an environment variable for the URI in production.\n * Fallback to the previous hard-coded URI for local dev if not set.\n */\nconst MONGODB_URI = process.env.MONGODB_URI || \"mongodb://localhost:27017/SocialDB\";\n\n/**\n * Global cache for the connection (useful for serverless / dev hot-reload).\n * We attach to global so multiple module reloads reuse the same connection.\n */\nlet cached = global.mongoose;\n\nif (!cached) {\n  cached = global.mongoose = { conn: null, promise: null };\n}\n\nasync function connectToDatabase() {\n  if (cached.conn) {\n    return cached.conn;\n  }\n\n  if (!cached.promise) {\n    // options can be tuned as needed\n    const opts = {\n      useNewUrlParser: true,\n      useUnifiedTopology: true,\n    };\n    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongooseInstance) => {\n      return mongooseInstance;\n    });\n  }\n\n  cached.conn = await cached.promise;\n  return cached.conn;\n}\n\n/**\n * Define schemas and models.\n * Use existing compiled models if present (mongoose.models).\n */\n\nconst locationSchema = new mongoose.Schema({ lat: Number, lng: Number }, { _id: false });\n\nconst userSchema = new mongoose.Schema({\n  firstName: { type: String, required: true },\n  lastName: { type: String, required: true },\n  gender: { type: String, required: true },\n  country: { type: String, required: true },\n  pseudo: { type: String, required: true },\n  email: { type: String, required: true, unique: true },\n  password: { type: String, required: true },\n  isOnline: { type: Boolean, default: false },\n  isValidated: { type: Boolean, default: false },\n  location: { type: locationSchema, default: null },\n  validationCode: { type: String, default: null },\n  recoveryCode: { type: String, default: null },\n}, { timestamps: true });\n\nconst postSchema = new mongoose.Schema({\n  content: { type: String, required: true },\n  dateTime: { type: Date, required: true, default: Date.now },\n  user: { type: mongoose.Schema.Types.ObjectId, ref: \"User\" },\n}, { timestamps: true });\n\n/**\n * Message schema - stores a single direct message between two users.\n * Fields:\n * - senderId: ObjectId (ref User)\n * - receiverId: ObjectId (ref User)\n * - text: String\n * - sentAt: Date\n */\nconst messageSchema = new mongoose.Schema({\n  senderId: { type: mongoose.Schema.Types.ObjectId, ref: \"User\", required: true },\n  receiverId: { type: mongoose.Schema.Types.ObjectId, ref: \"User\", required: true },\n  text: { type: String, required: true },\n  sentAt: { type: Date, required: true, default: Date.now },\n}, { timestamps: true });\n\n/**\n * Friend (friendship) schema - stores friend requests and accepted/refused relationships\n * Fields:\n * - senderId: ObjectId (ref User)  -> the user who initiated the request\n * - receiverId: ObjectId (ref User) -> the user receiving the request\n * - status: String -> 'pending' | 'accepted' | 'refused'\n */\nconst friendSchema = new mongoose.Schema({\n  senderId: { type: mongoose.Schema.Types.ObjectId, ref: \"User\", required: true },\n  receiverId: { type: mongoose.Schema.Types.ObjectId, ref: \"User\", required: true },\n  status: { type: String, enum: [\"pending\", \"accepted\", \"refused\"], default: \"pending\" },\n}, { timestamps: true });\n\n/**\n * Wallet schema - stores a walletId related to a user and its balance\n * Fields:\n * - walletId: String (unique wallet identifier)\n * - userId: ObjectId (ref User)\n * - balance: Number\n */\nconst walletSchema = new mongoose.Schema({\n  walletId: { type: String, required: true, unique: true },\n  userId: { type: mongoose.Schema.Types.ObjectId, ref: \"User\", required: true, unique: true },\n  balance: { type: Number, required: true, default: 0 },\n}, { timestamps: true });\n\n/**\n * Transaction schema - records transfers between wallets\n * Fields:\n * - senderWalletId: String (walletId of sender)\n * - receiverWalletId: String (walletId of receiver)\n * - amount: Number\n * - status: String (optional - pending/completed/failed)\n * - sentAt: Date\n */\nconst transactionSchema = new mongoose.Schema({\n  senderWalletId: { type: String, required: true },\n  receiverWalletId: { type: String, required: true },\n  amount: { type: Number, required: true },\n  status: { type: String, enum: [\"pending\", \"completed\", \"failed\"], default: \"completed\" },\n  sentAt: { type: Date, required: true, default: Date.now },\n}, { timestamps: true });\n\n/**\n * Avoid model overwrite in dev / hot-reload environments\n */\nconst User = mongoose.models.User || mongoose.model(\"User\", userSchema);\nconst Post = mongoose.models.Post || mongoose.model(\"Post\", postSchema);\nconst Message = mongoose.models.Message || mongoose.model(\"Message\", messageSchema);\nconst Friend = mongoose.models.Friend || mongoose.model(\"Friend\", friendSchema);\nconst Wallet = mongoose.models.Wallet || mongoose.model(\"Wallet\", walletSchema);\nconst Transaction = mongoose.models.Transaction || mongoose.model(\"Transaction\", transactionSchema);\n\n/**\n * Ensure connection is established when this module is imported.\n */\nconnectToDatabase().catch((err) => {\n  console.error(\"Failed to connect to MongoDB\", err);\n});\n\nexport { User, Post, Message, Friend, Wallet, Transaction, connectToDatabase };"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 318, "column": 0}, "map": {"version":3,"sources":["file:///D:/Saas_MongoDB/mongo/app/api/crypto/transfer/route.js"],"sourcesContent":["// app/api/crypto/transfer/route.js\r\nimport mongoose from 'mongoose';\r\n\r\nfunction jsonResponse(obj, status = 200) {\r\n  return new Response(JSON.stringify(obj), { status, headers: { 'Content-Type': 'application/json' } });\r\n}\r\nfunction jsonError(status, message) {\r\n  return jsonResponse({ success: false, error: message }, status);\r\n}\r\n\r\nexport async function POST(req) {\r\n  try {\r\n    const body = await req.json().catch(() => ({}));\r\n    const { fromWalletId, toWalletId, amount } = body || {};\r\n    const amt = Number(amount);\r\n\r\n    if (!fromWalletId || !toWalletId) return jsonError(400, 'fromWalletId and toWalletId are required');\r\n    if (!amt || isNaN(amt) || amt <= 0) return jsonError(400, 'amount must be a positive number');\r\n\r\n    // import models using the same pattern as other handlers in this repo\r\n    const modelsMod = await import('../../models').catch(() => null);\r\n    // support both ESM default and CommonJS shapes\r\n    const mod = modelsMod?.default || modelsMod || require('../../models');\r\n    const { Wallet, Transaction } = mod;\r\n\r\n    let session = null;\r\n    let txnSupported = true;\r\n\r\n    // Attempt transaction path\r\n    try {\r\n      session = await mongoose.startSession();\r\n      try {\r\n        session.startTransaction();\r\n      } catch (startErr) {\r\n        // Transactions not supported on standalone mongod -> fallback\r\n        txnSupported = false;\r\n      }\r\n\r\n      if (txnSupported) {\r\n        // debit sender atomically if they have enough balance\r\n        const sender = await Wallet.findOneAndUpdate(\r\n          { walletId: fromWalletId, balance: { $gte: amt } },\r\n          { $inc: { balance: -amt } },\r\n          { new: true, session }\r\n        );\r\n        if (!sender) {\r\n          await session.abortTransaction();\r\n          session.endSession();\r\n          return jsonError(400, 'Insufficient funds or sender not found');\r\n        }\r\n\r\n        // credit receiver\r\n        const receiver = await Wallet.findOneAndUpdate(\r\n          { walletId: toWalletId },\r\n          { $inc: { balance: amt } },\r\n          { new: true, session }\r\n        );\r\n        if (!receiver) {\r\n          await session.abortTransaction();\r\n          session.endSession();\r\n          return jsonError(404, 'Receiver not found');\r\n        }\r\n\r\n        // record transaction\r\n        await Transaction.create(\r\n          [{\r\n            senderWalletId: fromWalletId,\r\n            receiverWalletId: toWalletId,\r\n            amount: amt,\r\n            status: 'completed',\r\n          }],\r\n          { session }\r\n        );\r\n\r\n        await session.commitTransaction();\r\n        session.endSession();\r\n\r\n        return jsonResponse({ success: true, sender, receiver });\r\n      }\r\n    } catch (err) {\r\n      // If we get here and it's a transaction-related rejection, we'll fallback below\r\n      const txnErr = err && (err.code === 20 || (err.message && err.message.includes('Transaction numbers')));\r\n      if (!txnErr) {\r\n        // non-transaction error â€” try to clean up session then return error\r\n        try { if (session) { await session.abortTransaction(); session.endSession(); } } catch (e) {}\r\n        console.error('transfer error', err);\r\n        return jsonError(500, 'Transfer failed');\r\n      }\r\n      // else fall through to fallback path\r\n    }\r\n\r\n    // Fallback: best-effort non-transactional transfer (for standalone mongod)\r\n    try {\r\n      // 1) debit sender atomically if enough balance\r\n      const sender = await Wallet.findOneAndUpdate(\r\n        { walletId: fromWalletId, balance: { $gte: amt } },\r\n        { $inc: { balance: -amt } },\r\n        { new: true }\r\n      );\r\n      if (!sender) {\r\n        return jsonError(400, 'Insufficient funds or sender not found (no-transaction fallback)');\r\n      }\r\n\r\n      // 2) credit receiver\r\n      const receiver = await Wallet.findOneAndUpdate(\r\n        { walletId: toWalletId },\r\n        { $inc: { balance: amt } },\r\n        { new: true }\r\n      );\r\n      if (!receiver) {\r\n        // try to compensate: credit back the sender\r\n        await Wallet.findOneAndUpdate({ walletId: fromWalletId }, { $inc: { balance: amt } });\r\n        return jsonError(404, 'Receiver not found. Transfer aborted and sender compensated (best-effort)');\r\n      }\r\n\r\n      // record transaction (best-effort)\r\n      await Transaction.create({\r\n        senderWalletId: fromWalletId,\r\n        receiverWalletId: toWalletId,\r\n        amount: amt,\r\n        status: 'completed',\r\n      });\r\n\r\n      return jsonResponse({\r\n        success: true,\r\n        sender,\r\n        receiver,\r\n        warning: 'Performed without transaction (standalone mongod)',\r\n      });\r\n    } catch (fallbackErr) {\r\n      console.error('transfer fallback error', fallbackErr);\r\n      return jsonError(500, 'Fallback transfer failed');\r\n    }\r\n  } catch (err) {\r\n    console.error('transfer top-level error', err);\r\n    return jsonError(500, 'Internal server error');\r\n  }\r\n}"],"names":[],"mappings":"AAAA,mCAAmC;;;;;AACnC;;AAEA,SAAS,aAAa,GAAG,EAAE,SAAS,GAAG;IACrC,OAAO,IAAI,SAAS,KAAK,SAAS,CAAC,MAAM;QAAE;QAAQ,SAAS;YAAE,gBAAgB;QAAmB;IAAE;AACrG;AACA,SAAS,UAAU,MAAM,EAAE,OAAO;IAChC,OAAO,aAAa;QAAE,SAAS;QAAO,OAAO;IAAQ,GAAG;AAC1D;AAEO,eAAe,KAAK,GAAG;IAC5B,IAAI;QACF,MAAM,OAAO,MAAM,IAAI,IAAI,GAAG,KAAK,CAAC,IAAM,CAAC,CAAC,CAAC;QAC7C,MAAM,EAAE,YAAY,EAAE,UAAU,EAAE,MAAM,EAAE,GAAG,QAAQ,CAAC;QACtD,MAAM,MAAM,OAAO;QAEnB,IAAI,CAAC,gBAAgB,CAAC,YAAY,OAAO,UAAU,KAAK;QACxD,IAAI,CAAC,OAAO,MAAM,QAAQ,OAAO,GAAG,OAAO,UAAU,KAAK;QAE1D,sEAAsE;QACtE,MAAM,YAAY,MAAM,8FAAuB,KAAK,CAAC,IAAM;QAC3D,+CAA+C;QAC/C,MAAM,MAAM,WAAW,WAAW;QAClC,MAAM,EAAE,MAAM,EAAE,WAAW,EAAE,GAAG;QAEhC,IAAI,UAAU;QACd,IAAI,eAAe;QAEnB,2BAA2B;QAC3B,IAAI;YACF,UAAU,MAAM,oHAAQ,CAAC,YAAY;YACrC,IAAI;gBACF,QAAQ,gBAAgB;YAC1B,EAAE,OAAO,UAAU;gBACjB,8DAA8D;gBAC9D,eAAe;YACjB;YAEA,IAAI,cAAc;gBAChB,sDAAsD;gBACtD,MAAM,SAAS,MAAM,OAAO,gBAAgB,CAC1C;oBAAE,UAAU;oBAAc,SAAS;wBAAE,MAAM;oBAAI;gBAAE,GACjD;oBAAE,MAAM;wBAAE,SAAS,CAAC;oBAAI;gBAAE,GAC1B;oBAAE,KAAK;oBAAM;gBAAQ;gBAEvB,IAAI,CAAC,QAAQ;oBACX,MAAM,QAAQ,gBAAgB;oBAC9B,QAAQ,UAAU;oBAClB,OAAO,UAAU,KAAK;gBACxB;gBAEA,kBAAkB;gBAClB,MAAM,WAAW,MAAM,OAAO,gBAAgB,CAC5C;oBAAE,UAAU;gBAAW,GACvB;oBAAE,MAAM;wBAAE,SAAS;oBAAI;gBAAE,GACzB;oBAAE,KAAK;oBAAM;gBAAQ;gBAEvB,IAAI,CAAC,UAAU;oBACb,MAAM,QAAQ,gBAAgB;oBAC9B,QAAQ,UAAU;oBAClB,OAAO,UAAU,KAAK;gBACxB;gBAEA,qBAAqB;gBACrB,MAAM,YAAY,MAAM,CACtB;oBAAC;wBACC,gBAAgB;wBAChB,kBAAkB;wBAClB,QAAQ;wBACR,QAAQ;oBACV;iBAAE,EACF;oBAAE;gBAAQ;gBAGZ,MAAM,QAAQ,iBAAiB;gBAC/B,QAAQ,UAAU;gBAElB,OAAO,aAAa;oBAAE,SAAS;oBAAM;oBAAQ;gBAAS;YACxD;QACF,EAAE,OAAO,KAAK;YACZ,gFAAgF;YAChF,MAAM,SAAS,OAAO,CAAC,IAAI,IAAI,KAAK,MAAO,IAAI,OAAO,IAAI,IAAI,OAAO,CAAC,QAAQ,CAAC,sBAAuB;YACtG,IAAI,CAAC,QAAQ;gBACX,oEAAoE;gBACpE,IAAI;oBAAE,IAAI,SAAS;wBAAE,MAAM,QAAQ,gBAAgB;wBAAI,QAAQ,UAAU;oBAAI;gBAAE,EAAE,OAAO,GAAG,CAAC;gBAC5F,QAAQ,KAAK,CAAC,kBAAkB;gBAChC,OAAO,UAAU,KAAK;YACxB;QACA,qCAAqC;QACvC;QAEA,2EAA2E;QAC3E,IAAI;YACF,+CAA+C;YAC/C,MAAM,SAAS,MAAM,OAAO,gBAAgB,CAC1C;gBAAE,UAAU;gBAAc,SAAS;oBAAE,MAAM;gBAAI;YAAE,GACjD;gBAAE,MAAM;oBAAE,SAAS,CAAC;gBAAI;YAAE,GAC1B;gBAAE,KAAK;YAAK;YAEd,IAAI,CAAC,QAAQ;gBACX,OAAO,UAAU,KAAK;YACxB;YAEA,qBAAqB;YACrB,MAAM,WAAW,MAAM,OAAO,gBAAgB,CAC5C;gBAAE,UAAU;YAAW,GACvB;gBAAE,MAAM;oBAAE,SAAS;gBAAI;YAAE,GACzB;gBAAE,KAAK;YAAK;YAEd,IAAI,CAAC,UAAU;gBACb,4CAA4C;gBAC5C,MAAM,OAAO,gBAAgB,CAAC;oBAAE,UAAU;gBAAa,GAAG;oBAAE,MAAM;wBAAE,SAAS;oBAAI;gBAAE;gBACnF,OAAO,UAAU,KAAK;YACxB;YAEA,mCAAmC;YACnC,MAAM,YAAY,MAAM,CAAC;gBACvB,gBAAgB;gBAChB,kBAAkB;gBAClB,QAAQ;gBACR,QAAQ;YACV;YAEA,OAAO,aAAa;gBAClB,SAAS;gBACT;gBACA;gBACA,SAAS;YACX;QACF,EAAE,OAAO,aAAa;YACpB,QAAQ,KAAK,CAAC,2BAA2B;YACzC,OAAO,UAAU,KAAK;QACxB;IACF,EAAE,OAAO,KAAK;QACZ,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,UAAU,KAAK;IACxB;AACF","debugId":null}}]
}